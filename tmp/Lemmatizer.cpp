/****************************************************************************
**
** Metadata for LEMMATIZERLib generated by dumpcpp from type library
** Lemmatizer.tlb
**
****************************************************************************/

#define QAX_DUMPCPP_LEMMATIZERLIB_NOINLINES
#include "Lemmatizer.h"

using namespace LEMMATIZERLib;

static const uint qt_meta_data_LEMMATIZERLib__Paradigm[] = {

 // content:
       1,       // revision
       0,       // classname
       1,    10, // classinfo
       7,    12, // methods
       11,    47, // properties
       1,    80, // enums/sets

 // classinfo: key, value
       24, 36, 

 // signals: signature, parameters, type, tag, flags
       46, 85, 107, 108, 5,
       109, 134, 139, 140, 5,
       141, 167, 182, 183, 5,

 // slots: signature, parameters, type, tag, flags
       184, 197, 201, 206, 9,
       207, 220, 224, 232, 9,
       233, 244, 248, 256, 9,
       257, 285, 289, 293, 9,

 // properties: name, type, flags
       294, 305, 0x03005001, 		 // uint BaseLength
       310, 316, 0x03005001, 		 // uint Count
       321, 329, 0x02005001, 		 // int Founded
       333, 347, 0x02005001, 		 // int HomonymWeight
       351, 369, 0x02005001, 		 // int LemmaPrefixLength
       373, 378, 0x0a005001, 		 // QString Norm
       386, 397, 0x03005001, 		 // uint ParadigmID
       402, 412, 0x0a005001, 		 // QString SrcAncode
       420, 428, 0x0a005001, 		 // QString SrcNorm
       436, 447, 0x0a005001, 		 // QString TypeAncode
       455, 466, 0x02005001, 		 // int WordWeight

 // enums: name, flags, count, data
       470, 0x0, 3, 84, 

 // enum data: key, value
       514, LEMMATIZERLib::idlFinance,
       525, LEMMATIZERLib::idlComputer,
       537, LEMMATIZERLib::idlLiterature,

        0        // eod
};

static const char qt_meta_enumstringdata_LEMMATIZERLib[] = {
    "__MIDL___MIDL_itf_Lemmatizer_0000_0000_0001\0"
    "idlFinance\0idlComputer\0idlLiterature\0"

};

static const char *qt_meta_stringdata_LEMMATIZERLib__Paradigm() {
    static const char stringdata0[] = {
    "LEMMATIZERLib::Paradigm\0"
    "Interface 0\0IParadigm\0"
    "exception(int,QString,QString,QString)\0code,source,disc,help\0\0\0propertyChanged(QString)\0name\0\0\0signal(QString,int,void*)\0name,argc,argv\0\0\0"
    "Accent(uint)\0pos\0uint\0\0Ancode(uint)\0pos\0QString\0"
    "\0Form(uint)\0pos\0QString\0\0HomonymWeightWithForm(uint)\0pos\0int\0\0"
    "BaseLength\0uint\0Count\0uint\0Founded\0int\0HomonymWeight\0int\0LemmaPrefixLength\0int\0Norm\0QString\0ParadigmID\0uint\0SrcAncode\0QString\0SrcNorm\0QString\0"
    "TypeAncode\0QString\0WordWeight\0int\0"
    };
    static char data[sizeof(stringdata0) + sizeof(qt_meta_enumstringdata_LEMMATIZERLib)];
    if (!data[0]) {
        int index = 0;
        memcpy(data + index, stringdata0, sizeof(stringdata0) - 1);
        index += sizeof(stringdata0) - 1;
        memcpy(data + index, qt_meta_enumstringdata_LEMMATIZERLib, sizeof(qt_meta_enumstringdata_LEMMATIZERLib));
    }

    return data;
};

const QMetaObject Paradigm::staticMetaObject = {
{ &QObject::staticMetaObject,
qt_meta_stringdata_LEMMATIZERLib__Paradigm(),
qt_meta_data_LEMMATIZERLib__Paradigm }
};

void *Paradigm::qt_metacast(const char *_clname)
{
    if (!_clname) return 0;
    if (!strcmp(_clname, qt_meta_stringdata_LEMMATIZERLib__Paradigm()))
        return static_cast<void*>(const_cast<Paradigm*>(this));
    return QAxObject::qt_metacast(_clname);
}

static const uint qt_meta_data_LEMMATIZERLib__IParadigm[] = {

 // content:
       1,       // revision
       0,       // classname
       0,    0, // classinfo
       7,    10, // methods
       12,    45, // properties
       1,    81, // enums/sets

 // signals: signature, parameters, type, tag, flags
       25, 64, 86, 87, 5,
       88, 113, 118, 119, 5,
       120, 146, 161, 162, 5,

 // slots: signature, parameters, type, tag, flags
       163, 176, 180, 185, 9,
       186, 199, 203, 211, 9,
       212, 223, 227, 235, 9,
       236, 264, 268, 272, 9,

 // properties: name, type, flags
       273, 284, 0x03005001, 		 // uint BaseLength
       289, 295, 0x03005001, 		 // uint Count
       300, 308, 0x02005001, 		 // int Founded
       312, 326, 0x02005001, 		 // int HomonymWeight
       330, 348, 0x02005001, 		 // int LemmaPrefixLength
       352, 357, 0x0a005001, 		 // QString Norm
       365, 376, 0x03005001, 		 // uint ParadigmID
       381, 391, 0x0a005001, 		 // QString SrcAncode
       399, 407, 0x0a005001, 		 // QString SrcNorm
       415, 426, 0x0a005001, 		 // QString TypeAncode
       434, 445, 0x02005001, 		 // int WordWeight
       449, 457, 0x0a055003, 		 // QString control

 // enums: name, flags, count, data
       465, 0x0, 3, 85, 

 // enum data: key, value
       509, LEMMATIZERLib::idlFinance,
       520, LEMMATIZERLib::idlComputer,
       532, LEMMATIZERLib::idlLiterature,

        0        // eod
};

static const char *qt_meta_stringdata_LEMMATIZERLib__IParadigm() {
    static const char stringdata0[] = {
    "LEMMATIZERLib::IParadigm\0"
    "exception(int,QString,QString,QString)\0code,source,disc,help\0\0\0propertyChanged(QString)\0name\0\0\0signal(QString,int,void*)\0name,argc,argv\0\0\0"
    "Accent(uint)\0pos\0uint\0\0Ancode(uint)\0pos\0QString\0\0Form(uint)\0pos\0"
    "QString\0\0HomonymWeightWithForm(uint)\0pos\0int\0\0"
    "BaseLength\0uint\0Count\0uint\0Founded\0int\0HomonymWeight\0int\0LemmaPrefixLength\0int\0Norm\0QString\0ParadigmID\0uint\0SrcAncode\0QString\0SrcNorm\0QString\0TypeAncode\0QString\0"
    "WordWeight\0int\0control\0QString\0"
    };
    static char data[sizeof(stringdata0) + sizeof(qt_meta_enumstringdata_LEMMATIZERLib)];
    if (!data[0]) {
        int index = 0;
        memcpy(data + index, stringdata0, sizeof(stringdata0) - 1);
        index += sizeof(stringdata0) - 1;
        memcpy(data + index, qt_meta_enumstringdata_LEMMATIZERLib, sizeof(qt_meta_enumstringdata_LEMMATIZERLib));
    }

    return data;
};

const QMetaObject IParadigm::staticMetaObject = {
{ &QObject::staticMetaObject,
qt_meta_stringdata_LEMMATIZERLib__IParadigm(),
qt_meta_data_LEMMATIZERLib__IParadigm }
};

void *IParadigm::qt_metacast(const char *_clname)
{
    if (!_clname) return 0;
    if (!strcmp(_clname, qt_meta_stringdata_LEMMATIZERLib__IParadigm()))
        return static_cast<void*>(const_cast<IParadigm*>(this));
    return QAxObject::qt_metacast(_clname);
}

static const uint qt_meta_data_LEMMATIZERLib__ParadigmCollection[] = {

 // content:
       1,       // revision
       0,       // classname
       1,    10, // classinfo
       4,    12, // methods
       1,    32, // properties
       1,    35, // enums/sets

 // classinfo: key, value
       34, 46, 

 // signals: signature, parameters, type, tag, flags
       66, 105, 127, 128, 5,
       129, 154, 159, 160, 5,
       161, 187, 202, 203, 5,

 // slots: signature, parameters, type, tag, flags
       204, 214, 218, 229, 9,

 // properties: name, type, flags
       230, 236, 0x02005001, 		 // int Count

 // enums: name, flags, count, data
       240, 0x0, 3, 39, 

 // enum data: key, value
       284, LEMMATIZERLib::idlFinance,
       295, LEMMATIZERLib::idlComputer,
       307, LEMMATIZERLib::idlLiterature,

        0        // eod
};

static const char *qt_meta_stringdata_LEMMATIZERLib__ParadigmCollection() {
    static const char stringdata0[] = {
    "LEMMATIZERLib::ParadigmCollection\0"
    "Interface 0\0IParadigmCollection\0"
    "exception(int,QString,QString,QString)\0code,source,disc,help\0\0\0propertyChanged(QString)\0name\0\0\0signal(QString,int,void*)\0name,argc,argv\0\0\0"
    "Item(int)\0pos\0IParadigm*\0\0"
    "Count\0"
    "int\0"
    };
    static char data[sizeof(stringdata0) + sizeof(qt_meta_enumstringdata_LEMMATIZERLib)];
    if (!data[0]) {
        int index = 0;
        memcpy(data + index, stringdata0, sizeof(stringdata0) - 1);
        index += sizeof(stringdata0) - 1;
        memcpy(data + index, qt_meta_enumstringdata_LEMMATIZERLib, sizeof(qt_meta_enumstringdata_LEMMATIZERLib));
    }

    return data;
};

const QMetaObject ParadigmCollection::staticMetaObject = {
{ &QObject::staticMetaObject,
qt_meta_stringdata_LEMMATIZERLib__ParadigmCollection(),
qt_meta_data_LEMMATIZERLib__ParadigmCollection }
};

void *ParadigmCollection::qt_metacast(const char *_clname)
{
    if (!_clname) return 0;
    if (!strcmp(_clname, qt_meta_stringdata_LEMMATIZERLib__ParadigmCollection()))
        return static_cast<void*>(const_cast<ParadigmCollection*>(this));
    return QAxObject::qt_metacast(_clname);
}

static const uint qt_meta_data_LEMMATIZERLib__IParadigmCollection[] = {

 // content:
       1,       // revision
       0,       // classname
       0,    0, // classinfo
       4,    10, // methods
       2,    30, // properties
       1,    36, // enums/sets

 // signals: signature, parameters, type, tag, flags
       35, 74, 96, 97, 5,
       98, 123, 128, 129, 5,
       130, 156, 171, 172, 5,

 // slots: signature, parameters, type, tag, flags
       173, 183, 187, 198, 9,

 // properties: name, type, flags
       199, 205, 0x02005001, 		 // int Count
       209, 217, 0x0a055003, 		 // QString control

 // enums: name, flags, count, data
       225, 0x0, 3, 40, 

 // enum data: key, value
       269, LEMMATIZERLib::idlFinance,
       280, LEMMATIZERLib::idlComputer,
       292, LEMMATIZERLib::idlLiterature,

        0        // eod
};

static const char *qt_meta_stringdata_LEMMATIZERLib__IParadigmCollection() {
    static const char stringdata0[] = {
    "LEMMATIZERLib::IParadigmCollection\0"
    "exception(int,QString,QString,QString)\0code,source,disc,help\0\0\0propertyChanged(QString)\0name\0\0\0signal(QString,int,void*)\0name,argc,argv\0\0\0"
    "Item(int)\0pos\0IParadigm*\0\0"
    "Count\0int\0control\0QString\0"
    };
    static char data[sizeof(stringdata0) + sizeof(qt_meta_enumstringdata_LEMMATIZERLib)];
    if (!data[0]) {
        int index = 0;
        memcpy(data + index, stringdata0, sizeof(stringdata0) - 1);
        index += sizeof(stringdata0) - 1;
        memcpy(data + index, qt_meta_enumstringdata_LEMMATIZERLib, sizeof(qt_meta_enumstringdata_LEMMATIZERLib));
    }

    return data;
};

const QMetaObject IParadigmCollection::staticMetaObject = {
{ &QObject::staticMetaObject,
qt_meta_stringdata_LEMMATIZERLib__IParadigmCollection(),
qt_meta_data_LEMMATIZERLib__IParadigmCollection }
};

void *IParadigmCollection::qt_metacast(const char *_clname)
{
    if (!_clname) return 0;
    if (!strcmp(_clname, qt_meta_stringdata_LEMMATIZERLib__IParadigmCollection()))
        return static_cast<void*>(const_cast<IParadigmCollection*>(this));
    return QAxObject::qt_metacast(_clname);
}

static const uint qt_meta_data_LEMMATIZERLib__LemmatizerRussian[] = {

 // content:
       1,       // revision
       0,       // classname
       1,    10, // classinfo
       11,    12, // methods
       2,    67, // properties
       1,    73, // enums/sets

 // classinfo: key, value
       33, 45, 

 // signals: signature, parameters, type, tag, flags
       57, 96, 118, 119, 5,
       120, 145, 150, 151, 5,
       152, 178, 193, 194, 5,

 // slots: signature, parameters, type, tag, flags
       195, 213, 218, 222, 9,
       223, 273, 300, 321, 9,
       322, 372, 399, 420, 9,
       421, 447, 450, 461, 9,
       462, 489, 490, 491, 9,
       492, 559, 564, 565, 9,
       566, 592, 610, 611, 9,
       612, 633, 646, 647, 9,

 // properties: name, type, flags
       648, 666, 0x02015003, 		 // int MaximalPrediction
       670, 683, 0x02015003, 		 // int UseStatistic

 // enums: name, flags, count, data
       687, 0x0, 3, 77, 

 // enum data: key, value
       731, LEMMATIZERLib::idlFinance,
       742, LEMMATIZERLib::idlComputer,
       754, LEMMATIZERLib::idlLiterature,

        0        // eod
};

static const char *qt_meta_stringdata_LEMMATIZERLib__LemmatizerRussian() {
    static const char stringdata0[] = {
    "LEMMATIZERLib::LemmatizerRussian\0"
    "Interface 0\0ILemmatizer\0"
    "exception(int,QString,QString,QString)\0code,source,disc,help\0\0\0propertyChanged(QString)\0name\0\0\0signal(QString,int,void*)\0name,argc,argv\0\0\0"
    "CheckABC(QString)\0Word\0int\0\0CreateParadigmCollectionFromForm(QString,int,int)\0"
    "Form,capital,UsePrediction\0IParadigmCollection*\0\0CreateParadigmCollectionFromNorm(QString,int,int)\0Norm,capital,UsePrediction\0IParadigmCollection*\0\0CreateParadigmFromID(int)\0id\0IParadigm*\0\0LoadDictionariesRegistry()\0"
    "\0\0\0LoadStatisticRegistry(__MIDL___MIDL_itf_Lemmatizer_0000_0000_0001)\0subj\0\0\0SetMaximalPrediction(int)\0MaximalPrediction\0\0\0SetUseStatistic(int)\0UseStatistic\0\0\0"
    "MaximalPrediction\0int\0UseStatistic\0int\0"
    };
    static char data[sizeof(stringdata0) + sizeof(qt_meta_enumstringdata_LEMMATIZERLib)];
    if (!data[0]) {
        int index = 0;
        memcpy(data + index, stringdata0, sizeof(stringdata0) - 1);
        index += sizeof(stringdata0) - 1;
        memcpy(data + index, qt_meta_enumstringdata_LEMMATIZERLib, sizeof(qt_meta_enumstringdata_LEMMATIZERLib));
    }

    return data;
};

const QMetaObject LemmatizerRussian::staticMetaObject = {
{ &QObject::staticMetaObject,
qt_meta_stringdata_LEMMATIZERLib__LemmatizerRussian(),
qt_meta_data_LEMMATIZERLib__LemmatizerRussian }
};

void *LemmatizerRussian::qt_metacast(const char *_clname)
{
    if (!_clname) return 0;
    if (!strcmp(_clname, qt_meta_stringdata_LEMMATIZERLib__LemmatizerRussian()))
        return static_cast<void*>(const_cast<LemmatizerRussian*>(this));
    return QAxObject::qt_metacast(_clname);
}

static const uint qt_meta_data_LEMMATIZERLib__ILemmatizer[] = {

 // content:
       1,       // revision
       0,       // classname
       0,    0, // classinfo
       11,    10, // methods
       3,    65, // properties
       1,    74, // enums/sets

 // signals: signature, parameters, type, tag, flags
       27, 66, 88, 89, 5,
       90, 115, 120, 121, 5,
       122, 148, 163, 164, 5,

 // slots: signature, parameters, type, tag, flags
       165, 183, 188, 192, 9,
       193, 243, 270, 291, 9,
       292, 342, 369, 390, 9,
       391, 417, 420, 431, 9,
       432, 459, 460, 461, 9,
       462, 529, 534, 535, 9,
       536, 562, 580, 581, 9,
       582, 603, 616, 617, 9,

 // properties: name, type, flags
       618, 636, 0x02015003, 		 // int MaximalPrediction
       640, 653, 0x02015003, 		 // int UseStatistic
       657, 665, 0x0a055003, 		 // QString control

 // enums: name, flags, count, data
       673, 0x0, 3, 78, 

 // enum data: key, value
       717, LEMMATIZERLib::idlFinance,
       728, LEMMATIZERLib::idlComputer,
       740, LEMMATIZERLib::idlLiterature,

        0        // eod
};

static const char *qt_meta_stringdata_LEMMATIZERLib__ILemmatizer() {
    static const char stringdata0[] = {
    "LEMMATIZERLib::ILemmatizer\0"
    "exception(int,QString,QString,QString)\0code,source,disc,help\0\0\0propertyChanged(QString)\0name\0\0\0signal(QString,int,void*)\0name,argc,argv\0\0\0"
    "CheckABC(QString)\0Word\0int\0\0CreateParadigmCollectionFromForm(QString,int,int)\0"
    "Form,capital,UsePrediction\0IParadigmCollection*\0\0CreateParadigmCollectionFromNorm(QString,int,int)\0Norm,capital,UsePrediction\0IParadigmCollection*\0\0CreateParadigmFromID(int)\0id\0IParadigm*\0\0LoadDictionariesRegistry()\0"
    "\0\0\0LoadStatisticRegistry(__MIDL___MIDL_itf_Lemmatizer_0000_0000_0001)\0subj\0\0\0SetMaximalPrediction(int)\0MaximalPrediction\0\0\0SetUseStatistic(int)\0UseStatistic\0\0\0"
    "MaximalPrediction\0int\0UseStatistic\0int\0control\0"
    "QString\0"
    };
    static char data[sizeof(stringdata0) + sizeof(qt_meta_enumstringdata_LEMMATIZERLib)];
    if (!data[0]) {
        int index = 0;
        memcpy(data + index, stringdata0, sizeof(stringdata0) - 1);
        index += sizeof(stringdata0) - 1;
        memcpy(data + index, qt_meta_enumstringdata_LEMMATIZERLib, sizeof(qt_meta_enumstringdata_LEMMATIZERLib));
    }

    return data;
};

const QMetaObject ILemmatizer::staticMetaObject = {
{ &QObject::staticMetaObject,
qt_meta_stringdata_LEMMATIZERLib__ILemmatizer(),
qt_meta_data_LEMMATIZERLib__ILemmatizer }
};

void *ILemmatizer::qt_metacast(const char *_clname)
{
    if (!_clname) return 0;
    if (!strcmp(_clname, qt_meta_stringdata_LEMMATIZERLib__ILemmatizer()))
        return static_cast<void*>(const_cast<ILemmatizer*>(this));
    return QAxObject::qt_metacast(_clname);
}

static const uint qt_meta_data_LEMMATIZERLib__LemmatizerEnglish[] = {

 // content:
       1,       // revision
       0,       // classname
       1,    10, // classinfo
       11,    12, // methods
       2,    67, // properties
       1,    73, // enums/sets

 // classinfo: key, value
       33, 45, 

 // signals: signature, parameters, type, tag, flags
       57, 96, 118, 119, 5,
       120, 145, 150, 151, 5,
       152, 178, 193, 194, 5,

 // slots: signature, parameters, type, tag, flags
       195, 213, 218, 222, 9,
       223, 273, 300, 321, 9,
       322, 372, 399, 420, 9,
       421, 447, 450, 461, 9,
       462, 489, 490, 491, 9,
       492, 559, 564, 565, 9,
       566, 592, 610, 611, 9,
       612, 633, 646, 647, 9,

 // properties: name, type, flags
       648, 666, 0x02015003, 		 // int MaximalPrediction
       670, 683, 0x02015003, 		 // int UseStatistic

 // enums: name, flags, count, data
       687, 0x0, 3, 77, 

 // enum data: key, value
       731, LEMMATIZERLib::idlFinance,
       742, LEMMATIZERLib::idlComputer,
       754, LEMMATIZERLib::idlLiterature,

        0        // eod
};

static const char *qt_meta_stringdata_LEMMATIZERLib__LemmatizerEnglish() {
    static const char stringdata0[] = {
    "LEMMATIZERLib::LemmatizerEnglish\0"
    "Interface 0\0ILemmatizer\0"
    "exception(int,QString,QString,QString)\0code,source,disc,help\0\0\0propertyChanged(QString)\0name\0\0\0signal(QString,int,void*)\0name,argc,argv\0\0\0"
    "CheckABC(QString)\0Word\0int\0\0CreateParadigmCollectionFromForm(QString,int,int)\0"
    "Form,capital,UsePrediction\0IParadigmCollection*\0\0CreateParadigmCollectionFromNorm(QString,int,int)\0Norm,capital,UsePrediction\0IParadigmCollection*\0\0CreateParadigmFromID(int)\0id\0IParadigm*\0\0LoadDictionariesRegistry()\0"
    "\0\0\0LoadStatisticRegistry(__MIDL___MIDL_itf_Lemmatizer_0000_0000_0001)\0subj\0\0\0SetMaximalPrediction(int)\0MaximalPrediction\0\0\0SetUseStatistic(int)\0UseStatistic\0\0\0"
    "MaximalPrediction\0int\0UseStatistic\0int\0"
    };
    static char data[sizeof(stringdata0) + sizeof(qt_meta_enumstringdata_LEMMATIZERLib)];
    if (!data[0]) {
        int index = 0;
        memcpy(data + index, stringdata0, sizeof(stringdata0) - 1);
        index += sizeof(stringdata0) - 1;
        memcpy(data + index, qt_meta_enumstringdata_LEMMATIZERLib, sizeof(qt_meta_enumstringdata_LEMMATIZERLib));
    }

    return data;
};

const QMetaObject LemmatizerEnglish::staticMetaObject = {
{ &QObject::staticMetaObject,
qt_meta_stringdata_LEMMATIZERLib__LemmatizerEnglish(),
qt_meta_data_LEMMATIZERLib__LemmatizerEnglish }
};

void *LemmatizerEnglish::qt_metacast(const char *_clname)
{
    if (!_clname) return 0;
    if (!strcmp(_clname, qt_meta_stringdata_LEMMATIZERLib__LemmatizerEnglish()))
        return static_cast<void*>(const_cast<LemmatizerEnglish*>(this));
    return QAxObject::qt_metacast(_clname);
}

static const uint qt_meta_data_LEMMATIZERLib__LemmatizerGerman[] = {

 // content:
       1,       // revision
       0,       // classname
       1,    10, // classinfo
       11,    12, // methods
       2,    67, // properties
       1,    73, // enums/sets

 // classinfo: key, value
       32, 44, 

 // signals: signature, parameters, type, tag, flags
       56, 95, 117, 118, 5,
       119, 144, 149, 150, 5,
       151, 177, 192, 193, 5,

 // slots: signature, parameters, type, tag, flags
       194, 212, 217, 221, 9,
       222, 272, 299, 320, 9,
       321, 371, 398, 419, 9,
       420, 446, 449, 460, 9,
       461, 488, 489, 490, 9,
       491, 558, 563, 564, 9,
       565, 591, 609, 610, 9,
       611, 632, 645, 646, 9,

 // properties: name, type, flags
       647, 665, 0x02015003, 		 // int MaximalPrediction
       669, 682, 0x02015003, 		 // int UseStatistic

 // enums: name, flags, count, data
       686, 0x0, 3, 77, 

 // enum data: key, value
       730, LEMMATIZERLib::idlFinance,
       741, LEMMATIZERLib::idlComputer,
       753, LEMMATIZERLib::idlLiterature,

        0        // eod
};

static const char *qt_meta_stringdata_LEMMATIZERLib__LemmatizerGerman() {
    static const char stringdata0[] = {
    "LEMMATIZERLib::LemmatizerGerman\0"
    "Interface 0\0ILemmatizer\0"
    "exception(int,QString,QString,QString)\0code,source,disc,help\0\0\0propertyChanged(QString)\0name\0\0\0signal(QString,int,void*)\0name,argc,argv\0\0\0"
    "CheckABC(QString)\0Word\0int\0\0CreateParadigmCollectionFromForm(QString,int,int)\0"
    "Form,capital,UsePrediction\0IParadigmCollection*\0\0CreateParadigmCollectionFromNorm(QString,int,int)\0Norm,capital,UsePrediction\0IParadigmCollection*\0\0CreateParadigmFromID(int)\0id\0IParadigm*\0\0LoadDictionariesRegistry()\0"
    "\0\0\0LoadStatisticRegistry(__MIDL___MIDL_itf_Lemmatizer_0000_0000_0001)\0subj\0\0\0SetMaximalPrediction(int)\0MaximalPrediction\0\0\0SetUseStatistic(int)\0UseStatistic\0\0\0"
    "MaximalPrediction\0int\0UseStatistic\0int\0"
    };
    static char data[sizeof(stringdata0) + sizeof(qt_meta_enumstringdata_LEMMATIZERLib)];
    if (!data[0]) {
        int index = 0;
        memcpy(data + index, stringdata0, sizeof(stringdata0) - 1);
        index += sizeof(stringdata0) - 1;
        memcpy(data + index, qt_meta_enumstringdata_LEMMATIZERLib, sizeof(qt_meta_enumstringdata_LEMMATIZERLib));
    }

    return data;
};

const QMetaObject LemmatizerGerman::staticMetaObject = {
{ &QObject::staticMetaObject,
qt_meta_stringdata_LEMMATIZERLib__LemmatizerGerman(),
qt_meta_data_LEMMATIZERLib__LemmatizerGerman }
};

void *LemmatizerGerman::qt_metacast(const char *_clname)
{
    if (!_clname) return 0;
    if (!strcmp(_clname, qt_meta_stringdata_LEMMATIZERLib__LemmatizerGerman()))
        return static_cast<void*>(const_cast<LemmatizerGerman*>(this));
    return QAxObject::qt_metacast(_clname);
}

static const uint qt_meta_data_LEMMATIZERLib__PLMLineCollection[] = {

 // content:
       1,       // revision
       0,       // classname
       1,    10, // classinfo
       12,    12, // methods
       1,    72, // properties
       1,    75, // enums/sets

 // classinfo: key, value
       33, 45, 

 // signals: signature, parameters, type, tag, flags
       64, 103, 125, 126, 5,
       127, 152, 157, 158, 5,
       159, 185, 200, 201, 5,

 // slots: signature, parameters, type, tag, flags
       202, 233, 238, 239, 9,
       240, 248, 249, 250, 9,
       251, 272, 287, 288, 9,
       289, 299, 303, 311, 9,
       312, 342, 352, 353, 9,
       354, 381, 396, 397, 9,
       398, 410, 414, 415, 9,
       416, 436, 445, 446, 9,
       447, 468, 476, 477, 9,

 // properties: name, type, flags
       478, 484, 0x02005001, 		 // int Count

 // enums: name, flags, count, data
       488, 0x0, 3, 79, 

 // enum data: key, value
       532, LEMMATIZERLib::idlFinance,
       543, LEMMATIZERLib::idlComputer,
       555, LEMMATIZERLib::idlLiterature,

        0        // eod
};

static const char *qt_meta_stringdata_LEMMATIZERLib__PLMLineCollection() {
    static const char stringdata0[] = {
    "LEMMATIZERLib::PLMLineCollection\0"
    "Interface 0\0IPLMLineCollection\0"
    "exception(int,QString,QString,QString)\0code,source,disc,help\0\0\0propertyChanged(QString)\0name\0\0\0signal(QString,int,void*)\0name,argc,argv\0\0\0"
    "AttachLemmatizer(ILemmatizer*)\0pVal\0"
    "\0\0Clear()\0\0\0\0CopyItems(IUnknown*)\0piPlmLinesFrom\0\0\0Item(int)\0pos\0QString\0\0ProcessHyphenWords(IUnknown*)\0piGraphan\0\0\0ProcessPlmLines(IUnknown*)\0piGraphmatFile\0\0\0Remove(int)\0pos\0\0\0SaveToFile(QString)\0filename\0"
    "\0\0SetItem(int,QString)\0pos,rhs\0\0\0"
    "Count\0int\0"
    };
    static char data[sizeof(stringdata0) + sizeof(qt_meta_enumstringdata_LEMMATIZERLib)];
    if (!data[0]) {
        int index = 0;
        memcpy(data + index, stringdata0, sizeof(stringdata0) - 1);
        index += sizeof(stringdata0) - 1;
        memcpy(data + index, qt_meta_enumstringdata_LEMMATIZERLib, sizeof(qt_meta_enumstringdata_LEMMATIZERLib));
    }

    return data;
};

const QMetaObject PLMLineCollection::staticMetaObject = {
{ &QObject::staticMetaObject,
qt_meta_stringdata_LEMMATIZERLib__PLMLineCollection(),
qt_meta_data_LEMMATIZERLib__PLMLineCollection }
};

void *PLMLineCollection::qt_metacast(const char *_clname)
{
    if (!_clname) return 0;
    if (!strcmp(_clname, qt_meta_stringdata_LEMMATIZERLib__PLMLineCollection()))
        return static_cast<void*>(const_cast<PLMLineCollection*>(this));
    return QAxObject::qt_metacast(_clname);
}

static const uint qt_meta_data_LEMMATIZERLib__IPLMLineCollection[] = {

 // content:
       1,       // revision
       0,       // classname
       0,    0, // classinfo
       12,    10, // methods
       2,    70, // properties
       1,    76, // enums/sets

 // signals: signature, parameters, type, tag, flags
       34, 73, 95, 96, 5,
       97, 122, 127, 128, 5,
       129, 155, 170, 171, 5,

 // slots: signature, parameters, type, tag, flags
       172, 203, 208, 209, 9,
       210, 218, 219, 220, 9,
       221, 242, 257, 258, 9,
       259, 269, 273, 281, 9,
       282, 312, 322, 323, 9,
       324, 351, 366, 367, 9,
       368, 380, 384, 385, 9,
       386, 406, 415, 416, 9,
       417, 438, 446, 447, 9,

 // properties: name, type, flags
       448, 454, 0x02005001, 		 // int Count
       458, 466, 0x0a055003, 		 // QString control

 // enums: name, flags, count, data
       474, 0x0, 3, 80, 

 // enum data: key, value
       518, LEMMATIZERLib::idlFinance,
       529, LEMMATIZERLib::idlComputer,
       541, LEMMATIZERLib::idlLiterature,

        0        // eod
};

static const char *qt_meta_stringdata_LEMMATIZERLib__IPLMLineCollection() {
    static const char stringdata0[] = {
    "LEMMATIZERLib::IPLMLineCollection\0"
    "exception(int,QString,QString,QString)\0code,source,disc,help\0\0\0propertyChanged(QString)\0name\0\0\0signal(QString,int,void*)\0name,argc,argv\0\0\0"
    "AttachLemmatizer(ILemmatizer*)\0pVal\0\0\0Clear()\0\0\0\0CopyItems(IUnknown*)\0"
    "piPlmLinesFrom\0\0\0Item(int)\0pos\0QString\0\0ProcessHyphenWords(IUnknown*)\0piGraphan\0\0\0ProcessPlmLines(IUnknown*)\0piGraphmatFile\0\0\0Remove(int)\0pos\0\0\0SaveToFile(QString)\0filename\0\0\0SetItem(int,QString)\0pos,rhs\0"
    "\0\0"
    "Count\0int\0control\0QString\0"
    };
    static char data[sizeof(stringdata0) + sizeof(qt_meta_enumstringdata_LEMMATIZERLib)];
    if (!data[0]) {
        int index = 0;
        memcpy(data + index, stringdata0, sizeof(stringdata0) - 1);
        index += sizeof(stringdata0) - 1;
        memcpy(data + index, qt_meta_enumstringdata_LEMMATIZERLib, sizeof(qt_meta_enumstringdata_LEMMATIZERLib));
    }

    return data;
};

const QMetaObject IPLMLineCollection::staticMetaObject = {
{ &QObject::staticMetaObject,
qt_meta_stringdata_LEMMATIZERLib__IPLMLineCollection(),
qt_meta_data_LEMMATIZERLib__IPLMLineCollection }
};

void *IPLMLineCollection::qt_metacast(const char *_clname)
{
    if (!_clname) return 0;
    if (!strcmp(_clname, qt_meta_stringdata_LEMMATIZERLib__IPLMLineCollection()))
        return static_cast<void*>(const_cast<IPLMLineCollection*>(this));
    return QAxObject::qt_metacast(_clname);
}

